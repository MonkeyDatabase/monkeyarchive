---
layout: post
title: Wireshark入门(五)-展示过滤器
excerpt: "本文为阅读《Wirshark与Metasploit实战指南》的学习笔记。"
date:   2020-09-20 21:23:00
categories: [CyberSecurity]
comments: true
---

## 学习笔记

Wireshark最强大的特色是它内置的大量展示过滤器(在Wireshark 3.2.6版本有3000中协议中超过251000个字段)，它们可以让用户从未处理数据中高效提取出

### 1、对比运算符

| 英文表达 | C代码写法 | 含义                                                         |
| -------- | --------- | ------------------------------------------------------------ |
| eq       | ==        | 数值相等(当字段对应多个值，采用**或**的方式，只有其中一个值等于目标值，就显示这个分组) |
| ne       | !=        | 不相等(当字段对应多个值，采用**且**的方式，只有全部值都不等于目标值，才显示这个分组) |
| gt       | >         | 大于                                                         |
| lt       | <         | 小于                                                         |
| ge       | \>=       | 大于等于                                                     |
| le       | <=        | 小于等于                                                     |
| Contains |           | 测试过滤器字段中是否包含某个值                               |
| Matches  |           | 以Perl语法的正则匹配方式，测试表达式中的字段                 |

1. ip.addr == 8.8.8.8，只要发送方或接收方之一是8.8.8.8即可，可以过滤出8.8.8.8通信的所有数据包
2. ip.addr !=127.0.0.1，只有发送方和接收方都是127.0.0.1才会丢弃，但是这个情况在常规网络接口下是极少的，在Npcap Loopback Adapter和Adapter for loopback traffic capture这种捕获回环地址包的网络接口下才会出现，它们的链路层头为BSD loopback。
3. mac.addr != 00:01:02:03:04:05，返回值永远为真，即一个包都没过滤掉，所有包都被显示了，这是因为源mac和目的mac不会同时出现，导致这个条件永久为真。

**==**与**!=**是互补的，但是**!=**只是全集的一个元素，而**==**是全集中的去除**!=**这一种情况，随着字段对应值的数目的增加，**==**的情况大幅上涨，而**!=**的情况只有一个

当然单靠对比运算符一条表达式还不足以缩小范围，我们可以使用逻辑运算符组合多个由对比运算符组成的表达式。

### 2、逻辑运算符

| 英文表达 | C代码写法            | 含义                                                         |
| -------- | -------------------- | ------------------------------------------------------------ |
| and      | &&                   | 逻辑与，A && B：全部表达式是真的，则返回真值                 |
| or       | \|\|                 | 逻辑或，A \|\| B：至少有一个表达式为真，则返回真值           |
| xor      | ^^                   | 逻辑异或，A^^B：当xor两边的表达式只有一个为真时，返回真值    |
| not      | !                    | 逻辑非，!A：对表达式结果取反                                 |
|          | \[*start*:*length*\] | Slice运算符，使用这个运算符，可以截取字符串中的一段内容<br/>dns.resp.name[0:4]截取DNS响应名称里的前四个字符 |
|          | ()                   | 用括号为表达式分组                                           |

### 3、交互式创建展示过滤器

* 在要筛选的内容上，右键点击”作为过滤器应用“(会更新过滤器窗口中的表达式并执行)
  * 选中：以该字段eq该值，作为新表达式
  * 非选中：以该字段eq该值再not，作为新表达式
  * and selected：原表达式与该表达式and组成新表达式
  * .............
* 在要筛选的内容上，右键点击”Prepare as Filter“。(会更新过滤器窗口中的表达式但不执行)

## 独立思考

### 1. BSD loopback是什么？为什么用这个接口才会抓到127.0.0.1的包？

BSD loopback是一种回环网络接口的链路层头。

计算机以回环地址发送的消息，并不会由链路层发送，而是被本机网络层捕获。

127.0.0.1代表设备的本地虚拟接口，所以默认被看作永远不会宕机的接口。所以在网络出现故障时会有如下操作：

1. ping 127.0.0.1，通则表明本机TCP/IP协议栈正常
2. ping 本机ip，通则表明网络适配器工作正常
3. ping 同网段其他ip，通则表明网络线路正常
4. ping 网关，检查网关连接性
5. ping 远程网站，检查远程连接

**测试：**

1. 禁用所有网络适配器

   ![测试loopback，关闭全部网络适配器](https://s1.ax1x.com/2020/09/22/wXAl80.png)

2. 使用ipconfig查看ip配置情况，发现为空

   ```powershell
   C:\Users\xxxxx>ipconfig
   
   Windows IP 配置
   
   
   C:\Users\xxxxx>
   ```

3. ping 127.0.0.1，发现仍可以ping通

   ```powershell
   C:\Users\xxxxx>ping 127.0.0.1
   
   正在 Ping 127.0.0.1 具有 32 字节的数据:
   来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128
   来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128
   来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128
   来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128
   
   127.0.0.1 的 Ping 统计信息:
       数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
   往返行程的估计时间(以毫秒为单位):
       最短 = 0ms，最长 = 0ms，平均 = 0ms
   
   C:\Users\xxxxx>
   ```

   * 没有获取到ip的情况下，127.0.0.1仍可以访问
   * TCP/IP协议栈正常工作

4. 启动Wireshark，发现Npcap Loopback Adapter仍然有波形，说明Npcap Loopback Adapter被禁用与否都不影响Wireshark对loopback流量的捕获，只是需要有这个网络适配器存在即可

   ![所有Network Adapter被禁用的情况下，Wireshark的回环接口仍有波形](https://s1.ax1x.com/2020/09/23/wjZHHS.png)

5. 选中Npcap Loopback Adapter(目前仍为被禁用状态)，查看抓包情况，仍有大量设备发往自身的数据包

   ```shell
   
   Packet 0 from C:\Users652.pcapng
    9
    2.914277
    127.0.0.1
    127.0.0.1
    UDP
    33
    60947 → 60946 Len=1
   
   Packet 1 from C:\Users652.pcapng
    10
    2.916464
    127.0.0.1
    127.0.0.1
    UDP
    33
    60947 → 60946 Len=1
   ```
   
6. 浏览其中的数据包

   ```css
   Frame 9: 33 bytes on wire (264 bits), 33 bytes captured (264 bits) on interface \Device\[deleted], id 0
   Null/Loopback
   Internet Protocol Version 4, Src: 127.0.0.1, Dst: 127.0.0.1
   User Datagram Protocol, Src Port: 60947, Dst Port: 60946
   Data (1 byte)
   ```

   * 可以看出没有数据链路层的内容，这也证明了这个数据包没有经过数据链路层
   * 这个分组最低有网络层的分组，也验证了该分组被网络层捕获了


> 回环地址流量捕捉可见[官网](https://gitlab.com/wireshark/wireshark/-/wikis/CaptureSetup/Loopback)



## 产生过的疑问

1. BSD loopback是什么？为什么用这个接口才会抓到127.0.0.1的包？
2. 对比运算符中的*Matches*和*Contains*如何使用？